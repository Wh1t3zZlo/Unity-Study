# 渲染管线概述

## 应用阶段

1. 有CPU主导的 
2. 专门准备数据的阶段(比如顶点 法线 切线 纹理坐标 变换矩阵 材质属性 用于后续的使用 比如MVP变换需要顶点坐标 光照反射需要发现 纹理贴到模型上需要纹理坐标等) 
3. 准备好后发起一次DrawCall 而这个DrawCall就带着CPU准备好的数据 因此DrawCall过多会导致CPU性能消耗 性能瓶颈在于CPU



##  几何阶段 (貌似就是MVP变换)

**图元的定义取决于渲染管线在当前阶段如何理解和处理数据。** 简单来说，图元可以是一个点或一个三角形，是因为这是 GPU（图形处理器）被设计成处理的基本几何单位。

注意这里的图元里面的点还有线都不是单纯的维度上的概念, 点是可以有API设置半径的 同时线也可以设置宽度, 所以图元的大小除了三角形 点图元和线图元都是有开发者一开始就设置好了半径和宽度的



1. GPU主导阶段
2. 顶点着色器 (顶点坐标转换, 属性处理, 插值) 完全可编程 同时由于你对属性(颜色 切线 透明度 光照)的处理 就相当于改变他的材质 使他看起来像金属 或 布料 又或者像水面 注意注意 这里只是制造布料的褶皱 还有水面的波纹, 具体看起来的质感是由下面的片元着色器决定的 也就是说顶点着色器决定形状 片元着色器决定看起来的质感
3. 曲面细分着色器和几何着色器(不由开发者控制)
4. 裁剪 : 将视野范围(视锥体)外的图元进行裁剪 只保留能看到的(渲染管线自动处理)
5. 屏幕映射(MVP变换中的P 分为正交和透视 将空间中的点投影到屏幕上)





## 光栅化阶段

**片元**

可以理解为就是还==未被着色的潜在像素== 它包含了深度, 颜色, 法线, 纹理坐标等信息 像素就是一个单一颜色的块 片元才是本质 只是没上色 但他有颜色信息





1. GPU主导 确定片元是否渲染 以及片元的最终渲染颜色效果
2. 三角形设置 前面已经把空间中的点投影到屏幕上了, 那么每三个点构成一个三角形(图元阶段帮你处理好了, 就是决定哪几个顶点可以构成一个三角形 他不属于应用, 几何, 光栅化任意一个阶段 而是一个过渡阶段) 三角形设置为高效地进行光栅化做准备，它将一个三维的三角形转换成一系列二维数学方程和数据。 具体的就是把三角形每条边转换成一元一次的直线方程 还有确定插值方程, 比如我要访问三角形里面的某一个点的数据 可以根据这个插值方程算出他的深度, 法线, 纹理坐标
3. 三角形遍历 根据三角形设置得到的信息快速判断一个像素是否在某个三角形内, 也就是把三角形覆盖的每个像素生成一个片元 同时通过之前的插值方程算出该片元需要的信息 如深度 法线 颜色 纹理坐标等
4. 片元着色器(像素着色器)  完全可编程
	1. 光照处理 根据片元中的法线 等信息计算光照
	2. 纹理映射 根据纹理坐标对纹理采样 将纹理映射到片元上
	3. 材质属性处理 根据材质的属性 如颜色 透明度 反射率等 计算出最终的颜色和透明度 与上面的顶点着色器对应 片元着色器决定看起来的质感(因为反射率是由他控制的) 顶点着色器模拟布料的褶皱 
	4. 阴影计算 根据光源信息 计算片元是否处在阴影
5. 逐片元操作 对片元的数据进行各种处理计算  可配置
	1. 根据信息进行深度测试, 模板测试等
	2. 通过所有测试就把片元的颜色值和已存储在颜色缓冲区的颜色进行合并(混合)







# Shader语法

## 材质与Shader

[思维导图](https://www.mubu.com/doc/4cfk4NNm4i0)



## ShaderLab基本结构